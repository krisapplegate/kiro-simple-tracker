{
  "title": "[HIGH] Add Caching Layer",
  "body": "## Problem\n\nEvery request hits the database - no caching.\n\n## Issues\n\n- \u274c Repeated database queries for same data\n- \u274c RBAC permission checks on every request\n- \u274c Poor performance under load\n- \u274c Unnecessary database load\n- \u274c Higher cloud costs\n\n## Common Cache Candidates\n\n- User permissions (changes infrequently)\n- Role definitions (rarely changes)\n- Object type configurations\n- Tenant information\n- Frequently accessed objects\n\n## Recommendation\n\n```bash\nnpm install ioredis\n```\n\n```javascript\nconst Redis = require('ioredis')\nconst redis = new Redis(process.env.REDIS_URL)\n\n// Cache wrapper\nclass Cache {\n  async get(key) {\n    const cached = await redis.get(key)\n    return cached ? JSON.parse(cached) : null\n  }\n\n  async set(key, value, ttlSeconds = 300) {\n    await redis.setex(key, ttlSeconds, JSON.stringify(value))\n  }\n\n  async del(key) {\n    await redis.del(key)\n  }\n\n  async delPattern(pattern) {\n    const keys = await redis.keys(pattern)\n    if (keys.length > 0) {\n      await redis.del(...keys)\n    }\n  }\n}\n\nconst cache = new Cache()\n\n// Cache user permissions\nasync function getUserPermissions(userId, tenantId) {\n  const cacheKey = `permissions:${userId}:${tenantId}`\n\n  // Try cache first\n  let permissions = await cache.get(cacheKey)\n  if (permissions) {\n    return permissions\n  }\n\n  // Cache miss - fetch from database\n  permissions = await RBACService.getUserPermissions(userId, tenantId)\n\n  // Cache for 5 minutes\n  await cache.set(cacheKey, permissions, 300)\n\n  return permissions\n}\n\n// Invalidate on role change\nasync function assignRoleToUser(userId, roleId) {\n  await RBACService.assignRoleToUser(userId, roleId)\n\n  // Invalidate all permission caches for this user\n  await cache.delPattern(`permissions:${userId}:*`)\n}\n\n// Cache-aside pattern for objects\nasync function getObject(id, tenantId) {\n  const cacheKey = `object:${id}:${tenantId}`\n\n  let object = await cache.get(cacheKey)\n  if (object) {\n    return object\n  }\n\n  object = await objectRepository.findById(id, tenantId)\n  if (object) {\n    await cache.set(cacheKey, object, 600) // 10 minutes\n  }\n\n  return object\n}\n```\n\n## Cache Invalidation Strategy\n\n**Write-through:**\n- Update database\n- Update cache\n- If cache update fails, delete from cache\n\n**Time-based:**\n- Short TTL (1-5 minutes) for frequently changing data\n- Long TTL (1 hour+) for rarely changing data\n\n**Event-based:**\n- Invalidate on create/update/delete\n- Use cache key patterns for bulk invalidation\n\n## Implementation Steps\n\n1. Install and configure Redis\n2. Create cache wrapper class\n3. Identify cache candidates\n4. Implement cache-aside pattern\n5. Add cache invalidation logic\n6. Add cache metrics\n7. Test cache hit/miss behavior\n8. Document caching strategy\n\n## Success Criteria\n\n- [ ] Redis configured and operational\n- [ ] RBAC permissions cached\n- [ ] Cache hit rate > 70%\n- [ ] Proper cache invalidation\n- [ ] Cache metrics monitored\n- [ ] Documentation complete\n\n## Effort\n\n\u23f1\ufe0f **1 week**\n\n## Dependencies\n\n**Requires:** #12 (Repository pattern)\n\n## Phase\n\n**Phase 2 - High Priority** \ud83d\udfe0\n\n## Reference\n\n- `ARCHITECTURE_REVIEW.md` - Issue #13\n- `REFACTORING_ROADMAP.md` - Phase 2\n\n---\n\n**Metadata:**\n- **Effort:** 1 week\n- **Dependencies:** #12 (Repository pattern)\n",
  "labels": [
    "high-priority",
    "backend",
    "performance",
    "caching",
    "phase-2"
  ]
}