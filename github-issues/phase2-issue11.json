{
  "title": "[HIGH] Add Observability & Monitoring",
  "body": "## Problem\n\nNo application metrics, monitoring, or alerting.\n\n## Missing\n\n- \u274c Application metrics (response times, error rates)\n- \u274c Database performance monitoring\n- \u274c WebSocket connection metrics\n- \u274c Business metrics (objects created, locations updated)\n- \u274c Alerting on errors or anomalies\n- \u274c No observability into production issues\n\n## Recommendation\n\n```bash\nnpm install prom-client  # Prometheus metrics\n```\n\n```javascript\nconst prometheus = require('prom-client')\n\n// Create metrics\nconst httpRequestDuration = new prometheus.Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'Duration of HTTP requests in seconds',\n  labelNames: ['method', 'route', 'status']\n})\n\nconst objectsCreated = new prometheus.Counter({\n  name: 'objects_created_total',\n  help: 'Total number of objects created',\n  labelNames: ['tenant_id', 'type']\n})\n\nconst activeConnections = new prometheus.Gauge({\n  name: 'websocket_connections_active',\n  help: 'Number of active WebSocket connections',\n  labelNames: ['tenant_id']\n})\n\nconst dbQueryDuration = new prometheus.Histogram({\n  name: 'db_query_duration_seconds',\n  help: 'Duration of database queries',\n  labelNames: ['query_type', 'table']\n})\n\n// Middleware to track request duration\napp.use((req, res, next) => {\n  const start = Date.now()\n\n  res.on('finish', () => {\n    const duration = (Date.now() - start) / 1000\n    httpRequestDuration\n      .labels(req.method, req.route?.path || req.path, res.statusCode)\n      .observe(duration)\n  })\n\n  next()\n})\n\n// Expose metrics endpoint\napp.get('/metrics', async (req, res) => {\n  res.set('Content-Type', prometheus.register.contentType)\n  res.end(await prometheus.register.metrics())\n})\n\n// Business metrics\nobjectsCreated.labels(tenantId, type).inc()\nactiveConnections.labels(tenantId).set(wss.clients.size)\n```\n\n## Dashboards\n\nCreate Grafana dashboards for:\n- HTTP request rates and latency (p50, p95, p99)\n- Error rates by endpoint\n- Database query performance\n- WebSocket connection counts\n- Business metrics (objects created per hour, location updates)\n- Resource usage (CPU, memory, DB connections)\n\n## Alerting Rules\n\n- Error rate > 1% for 5 minutes\n- p95 latency > 1 second\n- Database connection pool exhausted\n- WebSocket connections > 10,000\n- Disk space < 10%\n\n## Implementation Steps\n\n1. Install prom-client\n2. Create metrics definitions\n3. Add metrics collection throughout app\n4. Expose /metrics endpoint\n5. Set up Prometheus scraping\n6. Create Grafana dashboards\n7. Configure alerting rules\n8. Document metrics\n\n## Success Criteria\n\n- [ ] Metrics exported in Prometheus format\n- [ ] /metrics endpoint secured\n- [ ] Dashboards showing key metrics\n- [ ] Alerts configured for critical issues\n- [ ] Documentation for all metrics\n\n## Effort\n\n\u23f1\ufe0f **1 week**\n\n## Dependencies\n\n**Requires:** #10 (Logging)\n**Blocks:** #18 (Enhanced health checks)\n\n## Phase\n\n**Phase 2 - High Priority** \ud83d\udfe0\n\n## Reference\n\n- `ARCHITECTURE_REVIEW.md` - Issue #11\n- `REFACTORING_ROADMAP.md` - Phase 2\n\n---\n\n**Metadata:**\n- **Effort:** 1 week\n- **Dependencies:** #10 (Logging) - BLOCKS: #18\n",
  "labels": [
    "high-priority",
    "backend",
    "monitoring",
    "observability",
    "phase-2"
  ]
}