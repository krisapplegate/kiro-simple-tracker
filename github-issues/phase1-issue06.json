{
  "title": "[CRITICAL] Implement Comprehensive Error Handling",
  "body": "## Problem\n\nInconsistent error handling throughout the application.\n\n**Current Issues:**\n\n```javascript\n// \u274c Generic errors - no context\ncatch (error) {\n  console.error('Error:', error)\n  res.status(500).json({ message: 'Server error' })\n}\n\n// \u274c Information disclosure\ncatch (error) {\n  res.status(500).json({ error: error.message })  // Exposes internals\n}\n\n// \u274c No error classification\n```\n\n## Issues\n\n- \u274c Generic 500 errors everywhere\n- \u274c Stack traces leaked in production\n- \u274c No error categorization (operational vs programming)\n- \u274c Inconsistent error responses\n- \u274c Difficult to debug production issues\n\n## Recommendation\n\nImplement centralized error handling:\n\n```javascript\n// middleware/errorHandler.js\nclass AppError extends Error {\n  constructor(message, statusCode, code) {\n    super(message)\n    this.statusCode = statusCode\n    this.code = code\n    this.isOperational = true\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\n// Common error types\nclass ValidationError extends AppError {\n  constructor(message, errors = []) {\n    super(message, 400, 'VALIDATION_ERROR')\n    this.errors = errors\n  }\n}\n\nclass UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED')\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource, id) {\n    super(`${resource} not found: ${id}`, 404, 'NOT_FOUND')\n  }\n}\n\n// Global error handler\nconst errorHandler = (err, req, res, next) => {\n  err.statusCode = err.statusCode || 500\n\n  if (process.env.NODE_ENV === 'development') {\n    return res.status(err.statusCode).json({\n      status: 'error',\n      error: err,\n      message: err.message,\n      stack: err.stack\n    })\n  }\n\n  // Production: Don't leak error details\n  if (err.isOperational) {\n    return res.status(err.statusCode).json({\n      status: 'error',\n      code: err.code,\n      message: err.message,\n      errors: err.errors\n    })\n  }\n\n  // Programming errors - log and send generic message\n  logger.error('Non-operational error:', err)\n  return res.status(500).json({\n    status: 'error',\n    message: 'Something went wrong'\n  })\n}\n```\n\n## Implementation Steps\n\n1. Create error classes (`AppError`, `ValidationError`, etc.)\n2. Create centralized error handler middleware\n3. Update all route handlers to use error classes\n4. Replace `console.error` with proper logging\n5. Add error tests\n6. Document error handling patterns\n\n## Success Criteria\n\n- [ ] All errors use error classes\n- [ ] Centralized error handler in place\n- [ ] No stack traces in production\n- [ ] Consistent error response format\n- [ ] Error handling tests added\n\n## Effort\n\n\u23f1\ufe0f **1 week**\n\n## Dependencies\n\n**Requires:** #1 (Refactor architecture)\n**Blocks:** #10 (Logging infrastructure)\n\n## Phase\n\n**Phase 1 - Critical** \ud83d\udd34\n\n## Reference\n\n- `ARCHITECTURE_REVIEW.md` - Issue #6\n- `REFACTORING_ROADMAP.md` - Phase 1\n\n---\n\n**Metadata:**\n- **Effort:** 1 week\n- **Dependencies:** #1 (Refactor architecture) - BLOCKS: #10\n",
  "labels": [
    "critical",
    "backend",
    "error-handling",
    "phase-1"
  ]
}