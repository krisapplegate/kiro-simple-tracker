{
  "title": "[HIGH] Implement Repository Pattern",
  "body": "## Problem\n\nDirect SQL queries in route handlers - difficult to maintain and test.\n\n**Current State:**\n```javascript\napp.get('/api/objects', authenticateToken, async (req, res) => {\n  const result = await query(\n    'SELECT * FROM objects WHERE tenant_id = $1',\n    [req.user.tenantId]\n  )  // \u274c SQL in route handler\n  res.json(result.rows)\n})\n```\n\n## Issues\n\n- \u274c SQL scattered throughout codebase\n- \u274c Difficult to test business logic\n- \u274c No query reusability\n- \u274c Hard to optimize database access\n- \u274c Cannot easily switch databases\n- \u274c Violates separation of concerns\n\n## Recommendation\n\nImplement Repository Pattern:\n\n```javascript\n// repositories/ObjectRepository.js\nclass ObjectRepository {\n  async findByTenant(tenantId, filters = {}) {\n    let queryText = 'SELECT * FROM objects WHERE tenant_id = $1'\n    const params = [tenantId]\n\n    if (filters.types?.length > 0) {\n      queryText += ' AND type = ANY($2)'\n      params.push(filters.types)\n    }\n\n    if (filters.tags?.length > 0) {\n      queryText += ' AND tags && $3'\n      params.push(filters.tags)\n    }\n\n    const result = await db.query(queryText, params)\n    return result.rows.map(this.mapToEntity)\n  }\n\n  async findById(id, tenantId) {\n    const result = await db.query(\n      'SELECT * FROM objects WHERE id = $1 AND tenant_id = $2',\n      [id, tenantId]\n    )\n    return result.rows[0] ? this.mapToEntity(result.rows[0]) : null\n  }\n\n  async create(objectData) {\n    const result = await db.query(\n      `INSERT INTO objects (name, type, lat, lng, tenant_id, created_by)\n       VALUES ($1, $2, $3, $4, $5, $6)\n       RETURNING *`,\n      [objectData.name, objectData.type, objectData.lat, objectData.lng,\n       objectData.tenantId, objectData.createdBy]\n    )\n    return this.mapToEntity(result.rows[0])\n  }\n\n  async update(id, tenantId, updates) {\n    // Implementation\n  }\n\n  async delete(id, tenantId) {\n    // Implementation\n  }\n\n  mapToEntity(row) {\n    return {\n      id: row.id,\n      name: row.name,\n      type: row.type,\n      lat: parseFloat(row.lat),\n      lng: parseFloat(row.lng),\n      createdAt: row.created_at,\n      updatedAt: row.updated_at\n    }\n  }\n}\n\nmodule.exports = new ObjectRepository()\n\n// Usage in service\nconst objectRepository = require('../repositories/ObjectRepository')\n\nclass ObjectService {\n  async getObjectsByTenant(tenantId, filters) {\n    return await objectRepository.findByTenant(tenantId, filters)\n  }\n}\n```\n\n## Implementation Steps\n\n1. Create `repositories/` directory\n2. Implement base repository with common methods\n3. Create repositories for each entity (Object, User, Tenant, etc.)\n4. Update services to use repositories\n5. Remove direct query calls from routes\n6. Add repository tests\n7. Document repository patterns\n\n## Success Criteria\n\n- [ ] All database access through repositories\n- [ ] No SQL in route handlers\n- [ ] Repository tests with >80% coverage\n- [ ] Consistent data mapping\n- [ ] Documentation complete\n\n## Effort\n\n\u23f1\ufe0f **2 weeks**\n\n## Dependencies\n\n**Requires:** #1 (Refactor architecture)\n**Blocks:** #13 (Caching layer)\n\n## Phase\n\n**Phase 2 - High Priority** \ud83d\udfe0\n\n## Reference\n\n- `ARCHITECTURE_REVIEW.md` - Issue #12\n- `REFACTORING_ROADMAP.md` - Phase 2\n\n---\n\n**Metadata:**\n- **Effort:** 2 weeks\n- **Dependencies:** #1 (Refactor architecture) - BLOCKS: #13\n",
  "labels": [
    "high-priority",
    "backend",
    "architecture",
    "database",
    "phase-2"
  ]
}